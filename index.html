<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL DE PANAM츼</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .leaflet-popup { margin-bottom: 70px !important; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; font-weight: bold; text-shadow: 0 0 5px white; }
        
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 280px; }
        input#search-input { flex: 1; border: none; padding: 8px; font-size: 14px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-weight: bold; }

        .leaflet-top.leaflet-right { top: 100px !important; }

        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); cursor: pointer; font-weight: bold; font-size: 11px; border: 1px solid #1a73e8; color: #1a73e8; }
        .toggle-watermark.off { color: #666; border-color: #ccc; }

        .watermark-label-fixed {
            background: none !important; border: none !important; box-shadow: none !important;
            color: #1a73e8 !important; font-weight: 400 !important;
            text-align: center; pointer-events: none !important; line-height: 1.1;
            text-shadow: 1px 1px 1px white;
        }
        .label-micro { font-size: 11px !important; }
        .label-macro { font-size: 14px !important; font-weight: 600 !important; }
        
        .btn-nav, .btn-ws { display: inline-block; margin-top: 8px; padding: 8px 12px; color: white !important; text-decoration: none !important; border-radius: 5px; font-weight: bold; font-size: 11px; border:none; cursor:pointer; }
        .btn-nav { background-color: #3498db; margin-right: 5px; }
        .btn-ws { background-color: #25D366; }
        .locate-button { background: white; width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; cursor: pointer; border-radius: 5px; font-size: 18px; border: 2px solid rgba(0,0,0,0.2); }
        
        /* Estilos cr칤ticos - SIN CAMBIOS */
        .leaflet-overlay-pane svg path,
        .leaflet-overlay-pane svg rect {
            shape-rendering: crispEdges;
            vector-effect: non-scaling-stroke;
        }
    </style>
</head>
<body>

<div class="map-title"><h1>SISTEMA POSTAL DE PANAM츼</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: J4199">
    <button id="search-btn">IR</button>
</div>

<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
const mymap = L.map('mapid', { 
    zoomControl: true, 
    zoomSnap: 0.1
}).setView([8.50, -80.0], 7.8);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Crear capas
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap); 
const selectionLayer = L.layerGroup().addTo(mymap);
const zonasGeoLayer = L.layerGroup().addTo(mymap); 
const cuadriculaLayer = L.layerGroup().addTo(mymap);
const rutasLayer = L.layerGroup().addTo(mymap);
const estafetasPointsLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawCuadricula = null;
let rawZonas = null;
const ALFABETO = "ABCDEFGHJKLMNPQRSTUVWXYZ"; 

// Funci칩n para extraer coordenadas exactas del pol칤gono real
function getMacroBounds(feature) {
    const coords = feature.geometry.coordinates[0];
    const lats = coords.map(c => c[1]);
    const lngs = coords.map(c => c[0]);
    return {
        minLat: Math.min(...lats),
        maxLat: Math.max(...lats),
        minLng: Math.min(...lngs),
        maxLng: Math.max(...lngs)
    };
}

// Funci칩n para crear la rejilla basada en las propiedades del pol칤gono
function createGridFromPolygon(feature) {
    const b = getMacroBounds(feature);
    const width = b.maxLng - b.minLng;
    const height = b.maxLat - b.minLat;
    
    // Usar row_index y col_index de las propiedades para consistencia
    const rowIndex = feature.properties.row_index;
    const colIndex = feature.properties.col_index;
    const macroCode = feature.properties.codigo;
    
    // Dividir en 24x24 celdas (micro)
    const cellWidth = width / 24;
    const cellHeight = height / 24;
    
    const grid = {
        bounds: b,
        width: width,
        height: height,
        cellWidth: cellWidth,
        cellHeight: cellHeight,
        rowIndex: rowIndex,
        colIndex: colIndex,
        macroCode: macroCode
    };
    
    return grid;
}

// Nueva funci칩n para calcular micro y nano basada en el pol칤gono real
function getHierarchicalDataFromPolygon(lat, lon, feature) {
    const b = getMacroBounds(feature);
    const sX = (b.maxLng - b.minLng) / 24;
    const sY = (b.maxLat - b.minLat) / 24;
    
    // 칈ndices dentro del macro
    const ix = Math.max(0, Math.min(23, Math.floor((lon - b.minLng) / sX)));
    const iy = Math.max(0, Math.min(23, Math.floor((lat - b.minLat) / sY)));
    
    const micro = `${ALFABETO[ix]}${ALFABETO[iy]}${ix % 10}${iy % 10}${Math.floor((ix + iy) / 5)}`;
    
    // Coordenadas EXACTAS de la celda micro
    const west = b.minLng + (ix * sX);
    const east = b.minLng + ((ix + 1) * sX);
    const south = b.minLat + (iy * sY);
    const north = b.minLat + ((iy + 1) * sY);
    
    const mRect = [[south, west], [north, east]];
    
    // Subdivisi칩n nano (10x10)
    const nsX = sX / 10;
    const nsY = sY / 10;
    const nix = Math.max(0, Math.min(9, Math.floor((lon - west) / nsX)));
    const niy = Math.max(0, Math.min(9, Math.floor((lat - south) / nsY)));
    
    const nano = `${ALFABETO[(nix * 7 + niy * 13) % 24]}${niy}`;
    
    const nWest = west + (nix * nsX);
    const nEast = west + ((nix + 1) * nsX);
    const nSouth = south + (niy * nsY);
    const nNorth = south + ((niy + 1) * nsY);
    
    const nRect = [[nSouth, nWest], [nNorth, nEast]];
    
    return { 
        micro, 
        nano, 
        mRect, 
        nRect,
        microWest: west,
        microEast: east,
        microSouth: south,
        microNorth: north,
        microIX: ix,
        microIY: iy
    };
}

// Variables de control
let labelsEnabled = true;
let updateTimeout;
let isDrawing = false;

// FUNCI칍N PRINCIPAL MEJORADA
function updateGridAndLabels() {
    if (isDrawing) return;
    isDrawing = true;
    
    // Limpiar capas
    gridLayer.clearLayers();
    labelLayer.clearLayers();
    
    const z = mymap.getZoom();
    if (!rawCuadricula || z < 10) {
        isDrawing = false;
        return;
    }

    const bounds = mymap.getBounds();
    const currentZoom = mymap.getZoom();
    
    requestAnimationFrame(() => {
        rawCuadricula.features.forEach(feature => {
            const grid = createGridFromPolygon(feature);
            const macroBounds = L.latLngBounds(
                [grid.bounds.minLat, grid.bounds.minLng],
                [grid.bounds.maxLat, grid.bounds.maxLng]
            );
            
            // Solo procesar si est치 visible
            if (!bounds.intersects(macroBounds)) return;
            
            const macroCode = grid.macroCode;
            const macroCenter = macroBounds.getCenter();

            // ETIQUETAS MACRO
            if (currentZoom >= 10 && currentZoom < 14 && labelsEnabled && mymap.hasLayer(cuadriculaLayer)) {
                if (bounds.contains(macroCenter)) {
                    L.marker(macroCenter, {
                        icon: L.divIcon({
                            className: 'watermark-label-fixed label-macro',
                            html: macroCode,
                            iconSize: [60, 20]
                        }),
                        interactive: false
                    }).addTo(labelLayer);
                }
            }

            // REJILLA MICRO (zoom 14-17)
            if (currentZoom >= 14 && currentZoom < 18 && mymap.hasLayer(gridLayer)) {
                // Calcular qu칠 celdas est치n visibles
                const visibleWest = Math.max(grid.bounds.minLng, bounds.getWest());
                const visibleEast = Math.min(grid.bounds.maxLng, bounds.getEast());
                const visibleSouth = Math.max(grid.bounds.minLat, bounds.getSouth());
                const visibleNorth = Math.min(grid.bounds.maxLat, bounds.getNorth());
                
                const startCol = Math.max(0, Math.floor((visibleWest - grid.bounds.minLng) / grid.cellWidth));
                const endCol = Math.min(23, Math.floor((visibleEast - grid.bounds.minLng) / grid.cellWidth));
                const startRow = Math.max(0, Math.floor((visibleSouth - grid.bounds.minLat) / grid.cellHeight));
                const endRow = Math.min(23, Math.floor((visibleNorth - grid.bounds.minLat) / grid.cellHeight));
                
                // Dibujar solo las celdas visibles
                for (let col = startCol; col <= endCol; col++) {
                    for (let row = startRow; row <= endRow; row++) {
                        // Coordenadas EXACTAS basadas en el origen del macro
                        const west = grid.bounds.minLng + (col * grid.cellWidth);
                        const east = grid.bounds.minLng + ((col + 1) * grid.cellWidth);
                        const south = grid.bounds.minLat + (row * grid.cellHeight);
                        const north = grid.bounds.minLat + ((row + 1) * grid.cellHeight);
                        
                        const cellBounds = L.latLngBounds([south, west], [north, east]);
                        
                        // Crear rect치ngulo micro con ajustes para evitar traslapes
                        const rectOptions = {
                            color: "#1a73e8",
                            weight: 0.3, // Peso M츼S FINO
                            opacity: 0.7,
                            fillOpacity: 0,
                            interactive: false,
                            lineCap: 'butt', // EXTREMO CUADRADO
                            lineJoin: 'miter', // UNI칍N EN 츼NGULO
                            renderer: L.canvas() // Forzar Canvas
                        };
                        
                        // Crear el rect치ngulo
                        const rect = L.rectangle(cellBounds, rectOptions);
                        
                        // Aplicar ajuste adicional para Canvas
                        if (rect._path) {
                            rect._path.style.strokeLinecap = 'butt';
                            rect._path.style.strokeLinejoin = 'miter';
                            rect._path.style.strokeMiterlimit = 10;
                        }
                        
                        gridLayer.addLayer(rect);
                        
                        // TEXTO WATERMARK para micro
                        if (labelsEnabled && mymap.hasLayer(cuadriculaLayer)) {
                            const microCode = `${ALFABETO[col]}${ALFABETO[row]}${col % 10}${row % 10}${Math.floor((col + row) / 5)}`;
                            const cellCenter = cellBounds.getCenter();
                            
                            if (bounds.contains(cellCenter)) {
                                L.marker(cellCenter, {
                                    icon: L.divIcon({
                                        className: 'watermark-label-fixed label-micro',
                                        html: `<div>${macroCode}</div><div>${microCode}</div>`,
                                        iconSize: [60, 30]
                                    }),
                                    interactive: false
                                }).addTo(labelLayer);
                            }
                        }
                    }
                }
            }
            
            // REJILLA NANO (zoom 18+)
            if (currentZoom >= 18 && mymap.hasLayer(gridLayer)) {
                // Solo dibujar nano cerca del centro del mapa
                const mapCenter = mymap.getCenter();
                const distance = mapCenter.distanceTo(macroCenter);
                
                if (distance < 2000) { // 2km de radio
                    // Encontrar la celda micro que contiene el centro del mapa
                    const centerLng = mapCenter.lng;
                    const centerLat = mapCenter.lat;
                    
                    if (centerLng >= grid.bounds.minLng && centerLng <= grid.bounds.maxLng &&
                        centerLat >= grid.bounds.minLat && centerLat <= grid.bounds.maxLat) {
                        
                        const microCol = Math.floor((centerLng - grid.bounds.minLng) / grid.cellWidth);
                        const microRow = Math.floor((centerLat - grid.bounds.minLat) / grid.cellHeight);
                        
                        if (microCol >= 0 && microCol < 24 && microRow >= 0 && microRow < 24) {
                            // Coordenadas de la celda micro
                            const microWest = grid.bounds.minLng + (microCol * grid.cellWidth);
                            const microEast = microWest + grid.cellWidth;
                            const microSouth = grid.bounds.minLat + (microRow * grid.cellHeight);
                            const microNorth = microSouth + grid.cellHeight;
                            
                            const nanoWidth = grid.cellWidth / 10;
                            const nanoHeight = grid.cellHeight / 10;
                            
                            // Dibujar rejilla nano completa para la celda micro seleccionada
                            for (let nCol = 0; nCol < 10; nCol++) {
                                for (let nRow = 0; nRow < 10; nRow++) {
                                    const nWest = microWest + (nCol * nanoWidth);
                                    const nEast = nWest + nanoWidth;
                                    const nSouth = microSouth + (nRow * nanoHeight);
                                    const nNorth = nSouth + nanoHeight;
                                    
                                    const nanoBounds = L.latLngBounds([nSouth, nWest], [nNorth, nEast]);
                                    
                                    if (bounds.intersects(nanoBounds)) {
                                        const nanoRect = L.rectangle(nanoBounds, {
                                            color: "#e67e22",
                                            weight: 0.15, // Peso MUY FINO
                                            opacity: 0.4,
                                            fillOpacity: 0.01,
                                            interactive: false,
                                            lineCap: 'butt',
                                            lineJoin: 'miter',
                                            renderer: L.canvas()
                                        });
                                        
                                        gridLayer.addLayer(nanoRect);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        });
        
        isDrawing = false;
    });
}

// Funci칩n debounced para actualizaciones
function debouncedUpdate() {
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() => {
        if (!isDrawing) {
            updateGridAndLabels();
        }
    }, 50);
}

// Control de etiquetas
$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).toggleClass('off').text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    debouncedUpdate();
});

// Eventos del mapa
mymap.on('overlayadd overlayremove moveend zoomend', debouncedUpdate);

// Cargar datos GeoJSON
$.getJSON("estafetas.geojson", d => { 
    rawZonas = d; 
    L.geoJSON(d, {
        style: {
            color: "#000", 
            weight: 1.5, 
            fillOpacity: 0.1, 
            fillColor: "#888"
        }
    }).addTo(zonasGeoLayer); 
});

$.getJSON("cuadricula.geojson", d => { 
    rawCuadricula = d; 
    L.geoJSON(d, {
        style: {
            color: "#2c3e50", 
            weight: 1, 
            fillOpacity: 0.05,
            lineCap: 'butt',
            lineJoin: 'miter'
        }
    }).addTo(cuadriculaLayer); 
    debouncedUpdate();
});

$.getJSON("estafetasl.geojson", d => L.geoJSON(d, {
    style: {
        color: "#e74c3c", 
        weight: 2
    }
}).addTo(rutasLayer));

$.getJSON("estafetasp.geojson", d => L.geoJSON(d, {
    pointToLayer: (f, ll) => L.circleMarker(ll, {
        radius: 6, 
        color: "#27ae60", 
        fillColor: "#2ecc71", 
        fillOpacity: 1
    })
}).addTo(estafetasPointsLayer));

// Evento click del mapa - ACTUALIZADO PARA USAR LA NUEVA FUNCI칍N
mymap.on("click", function (e) {
    selectionLayer.clearLayers();
    if (!rawCuadricula || !rawZonas) return;
    
    const hZ = leafletPip.pointInLayer([e.latlng.lng, e.latlng.lat], L.geoJSON(rawZonas));
    const hC = leafletPip.pointInLayer([e.latlng.lng, e.latlng.lat], L.geoJSON(rawCuadricula));

    if (hC.length === 0) {
        L.popup().setLatLng(e.latlng).setContent("<b>츼rea no v치lida</b>").openOn(mymap);
        return;
    }

    const useZonas = mymap.hasLayer(zonasGeoLayer) && hZ.length > 0;
    const macroID = useZonas ? hZ[0].feature.properties.VM_LEVEL : hC[0].feature.properties.codigo;
    const data = getHierarchicalDataFromPolygon(e.latlng.lat, e.latlng.lng, hC[0].feature);
    let titulo = "ZONAS POSTALES", finalCode = macroID;
    const z = mymap.getZoom();

    if (z < 14) {
        L.geoJSON(useZonas ? hZ[0].feature : hC[0].feature, {
            style: {
                color: "#1a73e8", 
                weight: 4, 
                fillOpacity: 0.3
            }
        }).addTo(selectionLayer);
    } else if (z >= 14 && z < 17) {
        titulo = "츼REA POSTAL";
        finalCode += `-${data.micro}`;
        L.rectangle(data.mRect, {
            color: "#1a73e8", 
            weight: 4, 
            fillOpacity: 0.2,
            lineCap: 'butt',
            lineJoin: 'miter'
        }).addTo(selectionLayer);
    } else {
        titulo = "C칍DIGO POSTAL";
        finalCode += `-${data.micro}-${data.nano}`;
        L.rectangle(data.nRect, {
            color: "#e67e22", 
            weight: 5, 
            fillOpacity: 0.4,
            lineCap: 'butt',
            lineJoin: 'miter'
        }).addTo(selectionLayer);
    }

    const ws = encodeURIComponent(`游늸 Mi ubicaci칩n: ${finalCode}\nGPS: ${e.latlng.lat.toFixed(6)},${e.latlng.lng.toFixed(6)}`);
    L.popup({offset:[0,-55]}).setLatLng(e.latlng).setContent(
        `<div style="text-align:center;">
            <small>${titulo}</small><br>
            <b>${finalCode}</b><br>
            <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${e.latlng.lat},${e.latlng.lng}')">游늸 MAPS</button>
            <button class="btn-ws" onclick="window.open('https://wa.me/?text=${ws}')">游눫 WS</button>
        </div>`
    ).openOn(mymap);
});

// B칰squeda
document.getElementById('search-btn').addEventListener('click', () => {
    const code = document.getElementById('search-input').value.trim().toUpperCase();
    if (!code || !rawCuadricula) return;
    let f = rawCuadricula.features.find(feat => feat.properties.codigo === code.split('-')[0]);
    if (f) mymap.fitBounds(L.geoJSON(f).getBounds());
});

// Localizaci칩n del usuario
mymap.on('locationfound', e => {
    userLocationLayer.clearLayers();
    L.circleMarker(e.latlng, { 
        radius: 7, 
        color: 'white', 
        fillColor: '#3498db', 
        fillOpacity: 1, 
        weight: 2 
    }).addTo(userLocationLayer);
});

// Control de localizaci칩n
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = '游꿢';
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:17}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// Control de capas
L.control.layers(null, {
    "Zonas": zonasGeoLayer,
    "Cuadr칤cula": cuadriculaLayer,
    "Rutas": rutasLayer,
    "Estafetas": estafetasPointsLayer,
    "Rejilla Din치mica": gridLayer
}, {collapsed: false}).addTo(mymap);
</script>
</body>
</html>
