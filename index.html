<!DOCTYPE html>
<html>
<head>
    <title>SISTEMA POSTAL DE PANAM츼 - FIX COMPLETO</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body, html, #mapid { width: 100%; height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; }
        .map-title { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 4000; text-align: center; pointer-events: none; width: 90%; }
        .map-title h1 { margin: 0; font-size: 18px; color: #2c3e50; text-shadow: 0 0 5px white; font-weight: bold; }
        .search-container { position: absolute; top: 15px; right: 10px; z-index: 5000; display: flex; background: white; padding: 5px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); width: 250px; }
        input#search-input { flex: 1; border: none; padding: 8px; outline: none; }
        button#search-btn { background: #2c3e50; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; }
        .leaflet-top.leaflet-right { top: 80px !important; }
        .toggle-watermark { position: absolute; bottom: 30px; left: 10px; z-index: 5000; background: white; padding: 10px; border-radius: 5px; cursor: pointer; font-size: 11px; border: 1px solid #1a73e8; font-weight: bold; }
        .watermark-label-fixed { background: none!important; border:none!important; color: #1a73e8!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; }
        .micro-label-fixed { background: none!important; border:none!important; color: #e67e22!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 9px; }
        .nano-label-fixed { background: none!important; border:none!important; color: #d35400!important; text-align: center; pointer-events: none!important; text-shadow: 1px 1px 1px white; font-size: 8px; }
        .btn-nav, .btn-ws { display: inline-block; padding: 8px 12px; color: white!important; text-decoration: none!important; border-radius: 5px; font-weight: bold; font-size: 11px; margin: 2px; border:none; cursor: pointer; }
        .btn-nav { background-color: #3498db; }
        .btn-ws { background-color: #25D366; }
        .locate-button { width: 30px; height: 30px; line-height: 30px; text-align: center; display: block; text-decoration: none; color: black; background: white; font-size: 18px; cursor: pointer; }
        .user-location-icon { text-align: center; font-size: 20px; }
        .highlighted-polygon { animation: pulse 2s infinite; }
        @keyframes pulse {
            0% { fill-opacity: 0.3; }
            50% { fill-opacity: 0.7; }
            100% { fill-opacity: 0.3; }
        }
    </style>
</head>
<body>

<div class="map-title"><h1>SISTEMA POSTAL DE PANAM츼</h1></div>
<div class="search-container">
    <input type="text" id="search-input" placeholder="Ej: J4199 o A6299-GT674">
    <button id="search-btn">IR</button>
</div>
<div id="toggle-wm" class="toggle-watermark">TEXTO: ON</div>
<div id="mapid"></div>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

<script>
const mymap = L.map('mapid').setView([8.50, -80.0], 8);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mymap);

// Capas
const zonasGeoLayer = L.layerGroup().addTo(mymap);
const cuadriculaFisicaLayer = L.layerGroup().addTo(mymap);
const gridLayer = L.layerGroup().addTo(mymap);
const labelLayer = L.layerGroup().addTo(mymap);
const selectionLayer = L.layerGroup().addTo(mymap);
const rutasLayer = L.layerGroup().addTo(mymap);
const estafetasPointsLayer = L.layerGroup().addTo(mymap);
const userLocationLayer = L.layerGroup().addTo(mymap);

let rawCuadricula = null, rawZonas = null;
let labelsEnabled = true;
const ALFABETO = "ABCDEFGHJKLMNPQRSTUVWXYZ";
const NANO_RES = 25; 

// CACHE para watermarks micro - para asegurar consistencia
const microWatermarkCache = new Map();

function getPointInGrid(coords, col, row, totalCols, totalRows) {
    const p0 = coords[0], p1 = coords[1], p2 = coords[2], p3 = coords[3];
    const tX = col / totalCols, tY = row / totalRows;
    const lat = (1-tY)*((1-tX)*p0[1] + tX*p1[1]) + tY*((1-tX)*p3[1] + tX*p2[1]);
    const lng = (1-tY)*((1-tX)*p0[0] + tX*p1[0]) + tY*((1-tX)*p3[0] + tX*p2[0]);
    return [lat, lng];
}

function getHierarchicalData(lat, lng, feature) {
    const b = L.geoJSON(feature).getBounds();
    const coords = feature.geometry.coordinates[0];
    
    // C치lculo SIMPLIFICADO y CONSISTENTE
    const width = b.getEast() - b.getWest();
    const height = b.getNorth() - b.getSouth();
    
    // C치lculo directo de 칤ndices - SIN AJUSTES COMPLEJOS
    const relX = (lng - b.getWest()) / width;
    const relY = (lat - b.getSouth()) / height;
    
    // Asegurar dentro de l칤mites
    const safeRelX = Math.min(0.9999999, Math.max(0.0000001, relX));
    const safeRelY = Math.min(0.9999999, Math.max(0.0000001, relY));
    
    // 칈ndices MICRO - igual que en updateGridAndLabels
    const ix = Math.floor(safeRelX * 24);
    const iy = Math.floor(safeRelY * 24);
    
    // Asegurar 칤ndices v치lidos
    const safeIx = Math.min(23, Math.max(0, ix));
    const safeIy = Math.min(23, Math.max(0, iy));
    
    // Formato micro - usando MISMA funci칩n
    const micro = getMicroCodeFromIndices(safeIx, safeIy);
    
    // Rect치ngulo micro - EXACTO
    const mRect = [
        getPointInGrid(coords, safeIx, safeIy, 24, 24),
        getPointInGrid(coords, safeIx+1, safeIy, 24, 24),
        getPointInGrid(coords, safeIx+1, safeIy+1, 24, 24),
        getPointInGrid(coords, safeIx, safeIy+1, 24, 24)
    ];

    // Para nano - c치lculo dentro de la celda micro
    const cellRelX = (safeRelX * 24) - safeIx;  // 0 a <1 dentro de la celda micro
    const cellRelY = (safeRelY * 24) - safeIy;  // 0 a <1 dentro de la celda micro
    
    const nix = Math.floor(cellRelX * NANO_RES);
    const niy = Math.floor(cellRelY * NANO_RES);
    
    // Asegurar 칤ndices nano v치lidos
    const safeNix = Math.min(NANO_RES-1, Math.max(0, nix));
    const safeNiy = Math.min(NANO_RES-1, Math.max(0, niy));
    
    const nano = `${ALFABETO[safeNix % 24]}${safeNiy % 10}`;

    // Rect치ngulo nano
    const nRect = [
        getPointInGrid(coords, safeIx + safeNix/NANO_RES, safeIy + safeNiy/NANO_RES, 24, 24),
        getPointInGrid(coords, safeIx + (safeNix+1)/NANO_RES, safeIy + safeNiy/NANO_RES, 24, 24),
        getPointInGrid(coords, safeIx + (safeNix+1)/NANO_RES, safeIy + (safeNiy+1)/NANO_RES, 24, 24),
        getPointInGrid(coords, safeIx + safeNix/NANO_RES, safeIy + (safeNiy+1)/NANO_RES, 24, 24)
    ];

    // Centros EXACTAMENTE igual que los watermarks
    const microCenter = getPointInGrid(coords, safeIx + 0.5, safeIy + 0.5, 24, 24);
    const nanoCenter = getPointInGrid(coords, safeIx + (safeNix + 0.5)/NANO_RES, safeIy + (safeNiy + 0.5)/NANO_RES, 24, 24);

    return { 
        micro, 
        nano, 
        mRect, 
        nRect, 
        microCenter,
        nanoCenter,
        indices: { ix: safeIx, iy: safeIy, nix: safeNix, niy: safeNiy }
    };
}

// Funci칩n para calcular c칩digo micro a partir de 칤ndices
function getMicroCodeFromIndices(ix, iy) {
    return `${ALFABETO[ix]}${ALFABETO[iy]}${ix % 10}${iy % 10}${Math.floor((ix + iy) / 5)}`;
}

// Funci칩n para obtener key del cache
function getCacheKey(featureId, ix, iy) {
    return `${featureId}-${ix}-${iy}`;
}

function updateGridAndLabels() {
    gridLayer.clearLayers();
    labelLayer.clearLayers();
    microWatermarkCache.clear(); // Limpiar cache
    
    if (!rawCuadricula) return;
    const z = mymap.getZoom();
    const bounds = mymap.getBounds();

    rawCuadricula.features.forEach((f, featureIndex) => {
        const fBounds = L.geoJSON(f).getBounds();
        if (!bounds.intersects(fBounds)) return;
        
        // Labels para macro (zoom 10-14)
        if (z >= 10 && z < 14 && labelsEnabled) {
            L.marker(fBounds.getCenter(), {
                icon: L.divIcon({ 
                    className: 'watermark-label-fixed', 
                    html: f.properties.codigo, 
                    iconSize: [60, 20] 
                })
            }).addTo(labelLayer);
        }
        
        // Labels para micro (zoom 14-17) - CENTRADOS CORRECTAMENTE
        if (z >= 14 && z < 17 && labelsEnabled) {
            const coords = f.geometry.coordinates[0];
            // Mostrar TODAS las celdas micro para coincidir con clic
            for (let i = 0; i < 24; i++) {
                for (let j = 0; j < 24; j++) {
                    // Centro EXACTO de la celda
                    const center = getPointInGrid(coords, i + 0.5, j + 0.5, 24, 24);
                    const microCode = getMicroCodeFromIndices(i, j);
                    
                    // Guardar en cache para referencia
                    const cacheKey = getCacheKey(featureIndex, i, j);
                    microWatermarkCache.set(cacheKey, {
                        center: center,
                        code: microCode,
                        bounds: [
                            getPointInGrid(coords, i, j, 24, 24),
                            getPointInGrid(coords, i+1, j, 24, 24),
                            getPointInGrid(coords, i+1, j+1, 24, 24),
                            getPointInGrid(coords, i, j+1, 24, 24)
                        ]
                    });
                    
                    L.marker(center, {
                        icon: L.divIcon({ 
                            className: 'micro-label-fixed', 
                            html: microCode, 
                            iconSize: [45, 15] 
                        })
                    }).addTo(labelLayer);
                }
            }
        }

        // REJILLA DIN츼MICA - CON PUNTEO NANO
        if (z >= 14 && mymap.hasLayer(gridLayer)) {
            const coords = f.geometry.coordinates[0];
            
            // L칤neas principales MICRO
            for (let i = 0; i <= 24; i++) {
                let v = [], h = [];
                for(let j=0; j<=24; j++) {
                    v.push(getPointInGrid(coords, i, j, 24, 24));
                    h.push(getPointInGrid(coords, j, i, 24, 24));
                }
                
                let weight, opacity;
                if (z >= 14 && z < 17) {
                    // 츼REA POSTAL
                    weight = 1.5;
                    opacity = 0.5;
                } else {
                    // C칍DIGO POSTAL
                    weight = 0.8;
                    opacity = 0.4;
                }
                
                L.polyline(v, {color: '#3498db', weight: weight, opacity: opacity}).addTo(gridLayer);
                L.polyline(h, {color: '#3498db', weight: weight, opacity: opacity}).addTo(gridLayer);
            }
            
            // L칤neas punteadas NANO (solo zoom >=17)
            if (z >= 17) {
                for (let i = 0; i < 24; i++) {
                    for (let j = 0; j < 24; j++) {
                        // Calcular v칠rtices de la celda micro
                        const topLeft = getPointInGrid(coords, i, j, 24, 24);
                        const topRight = getPointInGrid(coords, i+1, j, 24, 24);
                        const bottomRight = getPointInGrid(coords, i+1, j+1, 24, 24);
                        const bottomLeft = getPointInGrid(coords, i, j+1, 24, 24);
                        
                        // L칤neas verticales NANO (punteadas)
                        for (let ni = 1; ni < NANO_RES; ni++) {
                            const t = ni / NANO_RES;
                            const p1 = [
                                (1-t) * topLeft[0] + t * topRight[0],
                                (1-t) * topLeft[1] + t * topRight[1]
                            ];
                            const p2 = [
                                (1-t) * bottomLeft[0] + t * bottomRight[0],
                                (1-t) * bottomLeft[1] + t * bottomRight[1]
                            ];
                            L.polyline([p1, p2], {
                                color: '#2980b9', 
                                weight: 0.4,
                                opacity: 0.3,
                                dashArray: '3,3'  // PUNTEO
                            }).addTo(gridLayer);
                        }
                        
                        // L칤neas horizontales NANO (punteadas)
                        for (let nj = 1; nj < NANO_RES; nj++) {
                            const t = nj / NANO_RES;
                            const p1 = [
                                (1-t) * topLeft[0] + t * bottomLeft[0],
                                (1-t) * topLeft[1] + t * bottomLeft[1]
                            ];
                            const p2 = [
                                (1-t) * topRight[0] + t * bottomRight[0],
                                (1-t) * topRight[1] + t * bottomRight[1]
                            ];
                            L.polyline([p1, p2], {
                                color: '#2980b9', 
                                weight: 0.4,
                                opacity: 0.3,
                                dashArray: '3,3'  // PUNTEO
                            }).addTo(gridLayer);
                        }
                    }
                }
            }
        }
    });
}

// Carga de Datos
$.getJSON("cuadricula.geojson", d => { 
    rawCuadricula = d; 
    L.geoJSON(d, {style: {color: "#3498db", weight: 1, fillOpacity: 0.05}}).addTo(cuadriculaFisicaLayer);
    updateGridAndLabels(); 
});
$.getJSON("estafetas.geojson", d => { 
    rawZonas = d; 
    L.geoJSON(d, {style: {color: "#2c3e50", weight: 1.5, fillOpacity: 0.05}}).addTo(zonasGeoLayer); 
});
$.getJSON("estafetasl.geojson", d => L.geoJSON(d, {style: {color: "#e74c3c", weight: 2}}).addTo(rutasLayer));
$.getJSON("estafetasp.geojson", d => L.geoJSON(d, {pointToLayer:(f,ll)=>L.circleMarker(ll,{radius:5, color:"#27ae60", fillColor:"#2ecc71", fillOpacity:1})}).addTo(estafetasPointsLayer));

// EVENTO CLIC - VERSI칍N SIMPLIFICADA Y SINCRO
mymap.on("click", function (e) {
    console.log("Clic en:", e.latlng.lat.toFixed(6), e.latlng.lng.toFixed(6));
    selectionLayer.clearLayers();
    if (!rawCuadricula || !rawZonas) return;
    
    const hZ = leafletPip.pointInLayer([e.latlng.lng, e.latlng.lat], L.geoJSON(rawZonas));
    const hC = leafletPip.pointInLayer([e.latlng.lng, e.latlng.lat], L.geoJSON(rawCuadricula));

    if (hC.length === 0) return;

    const useZonas = mymap.hasLayer(zonasGeoLayer) && hZ.length > 0;
    const macroID = useZonas ? hZ[0].feature.properties.VM_LEVEL : hC[0].feature.properties.codigo;
    
    let titulo = "ZONAS POSTALES", finalCode = macroID;
    const z = mymap.getZoom();

    if (z < 14) {
        // Nivel macro - funciona bien
        const selectedFeature = useZonas ? hZ[0].feature : hC[0].feature;
        L.geoJSON(selectedFeature, {
            style: {
                color: "#1a73e8", 
                weight: 4, 
                fillColor: "#1a73e8",
                fillOpacity: 0.3,
                className: 'highlighted-polygon'
            }
        }).addTo(selectionLayer);
        
    } else if (z >= 14 && z < 17) {
        // NIVEL MICRO - USANDO CACHE para coincidir exactamente con watermarks
        const featureIndex = rawCuadricula.features.findIndex(f => f === hC[0].feature);
        
        // Buscar el watermark m치s cercano al punto de clic
        let closestWatermark = null;
        let minDistance = Infinity;
        
        // Buscar en el cache
        for (let i = 0; i < 24; i++) {
            for (let j = 0; j < 24; j++) {
                const cacheKey = getCacheKey(featureIndex, i, j);
                const watermark = microWatermarkCache.get(cacheKey);
                if (watermark) {
                    const distance = Math.sqrt(
                        Math.pow(e.latlng.lat - watermark.center[0], 2) +
                        Math.pow(e.latlng.lng - watermark.center[1], 2)
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestWatermark = watermark;
                    }
                }
            }
        }
        
        if (closestWatermark) {
            titulo = "츼REA POSTAL";
            finalCode += `-${closestWatermark.code}`;
            
            // Usar bounds del cache (exactamente igual a watermark)
            L.polygon(closestWatermark.bounds, {
                color: "#1a73e8", 
                weight: 3, 
                fillColor: "#1a73e8",
                fillOpacity: 0.5,
                className: 'highlighted-polygon'
            }).addTo(selectionLayer);
            
            // Label en el centro exacto del watermark
            L.marker(closestWatermark.center, {
                icon: L.divIcon({ 
                    className: 'micro-label-fixed', 
                    html: closestWatermark.code, 
                    iconSize: [60, 18] 
                })
            }).addTo(selectionLayer);
            
            console.log("Micro seleccionado:", closestWatermark.code, "칤ndices encontrados en cache");
        } else {
            // Fallback a c치lculo normal
            try {
                const data = getHierarchicalData(e.latlng.lat, e.latlng.lng, hC[0].feature);
                titulo = "츼REA POSTAL";
                finalCode += `-${data.micro}`;
                
                L.polygon(data.mRect, {
                    color: "#1a73e8", 
                    weight: 3, 
                    fillColor: "#1a73e8",
                    fillOpacity: 0.5,
                    className: 'highlighted-polygon'
                }).addTo(selectionLayer);
                
                L.marker(data.microCenter, {
                    icon: L.divIcon({ 
                        className: 'micro-label-fixed', 
                        html: data.micro, 
                        iconSize: [60, 18] 
                    })
                }).addTo(selectionLayer);
            } catch (err) {
                console.error("Error:", err);
            }
        }
    } else {
        // NIVEL NANO
        try {
            const data = getHierarchicalData(e.latlng.lat, e.latlng.lng, hC[0].feature);
            titulo = "C칍DIGO POSTAL";
            finalCode += `-${data.micro}-${data.nano}`;
            
            L.polygon(data.nRect, {
                color: "#e67e22", 
                weight: 2, 
                fillColor: "#e67e22",
                fillOpacity: 0.6,
                className: 'highlighted-polygon'
            }).addTo(selectionLayer);
            
            L.marker(data.nanoCenter, {
                icon: L.divIcon({ 
                    className: 'nano-label-fixed', 
                    html: data.nano, 
                    iconSize: [50, 15] 
                })
            }).addTo(selectionLayer);
            
        } catch (err) {
            console.error("Error en nano:", err);
        }
    }

    const ws = encodeURIComponent(`游늸 Mi ubicaci칩n: ${finalCode}\nGPS: ${e.latlng.lat.toFixed(6)},${e.latlng.lng.toFixed(6)}`);
    L.popup({offset:[0,-5]}).setLatLng(e.latlng).setContent(`
        <div style="text-align:center;">
            <small>${titulo}</small><br>
            <b>${finalCode}</b><br>
            <button class="btn-nav" onclick="window.open('https://www.google.com/maps?q=${e.latlng.lat},${e.latlng.lng}')">游늸 MAPS</button>
            <button class="btn-ws" onclick="window.open('https://wa.me/?text=${ws}')">游눫 WS</button>
        </div>
    `).openOn(mymap);
});

// BUSCADOR
document.getElementById('search-btn').addEventListener('click', () => {
    const code = document.getElementById('search-input').value.trim().toUpperCase();
    if (!code || !rawCuadricula) return;
    
    const macroPart = code.split('-')[0];
    let f = rawCuadricula.features.find(feat => feat.properties.codigo === macroPart);
    
    if (f) {
        if (code.includes('-')) {
            const microPart = code.split('-')[1];
            if (microPart && microPart.length >= 2) {
                const firstChar = microPart.charAt(0);
                const secondChar = microPart.charAt(1);
                const ix = ALFABETO.indexOf(firstChar);
                const iy = ALFABETO.indexOf(secondChar);
                
                if (ix !== -1 && iy !== -1) {
                    const coords = f.geometry.coordinates[0];
                    const center = getPointInGrid(coords, ix + 0.5, iy + 0.5, 24, 24);
                    mymap.setView(center, 16);
                    
                    selectionLayer.clearLayers();
                    const mRect = [
                        getPointInGrid(coords, ix, iy, 24, 24),
                        getPointInGrid(coords, ix+1, iy, 24, 24),
                        getPointInGrid(coords, ix+1, iy+1, 24, 24),
                        getPointInGrid(coords, ix, iy+1, 24, 24)
                    ];
                    
                    const microCode = getMicroCodeFromIndices(ix, iy);
                    
                    L.polygon(mRect, {
                        color: "#1a73e8", 
                        weight: 3, 
                        fillColor: "#1a73e8",
                        fillOpacity: 0.5,
                        className: 'highlighted-polygon'
                    }).addTo(selectionLayer);
                    
                    L.marker(center, {
                        icon: L.divIcon({ 
                            className: 'micro-label-fixed', 
                            html: microCode, 
                            iconSize: [60, 18] 
                        })
                    }).addTo(selectionLayer);
                    
                    return;
                }
            }
        }
        
        mymap.fitBounds(L.geoJSON(f).getBounds(), {padding: [50, 50]});
    } else {
        alert("C칩digo postal no encontrado: " + code);
    }
});

// GPS
const LocateControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function() {
        const c = L.DomUtil.create('div', 'leaflet-bar');
        const b = L.DomUtil.create('a', 'locate-button', c);
        b.innerHTML = '游꿢';
        b.title = "Ubicar mi posici칩n";
        L.DomEvent.on(b, 'click', e => { 
            L.DomEvent.stopPropagation(e); 
            mymap.locate({setView:true, maxZoom:18}); 
        });
        return c;
    }
});
mymap.addControl(new LocateControl());

// CONTROL DE CAPAS
L.control.layers(null, {
    "Zonas": zonasGeoLayer,
    "Cuadr칤cula": cuadriculaFisicaLayer,
    "Rutas": rutasLayer,
    "Estafetas": estafetasPointsLayer,
    "C칩digo postal": gridLayer,
    "Selecci칩n": selectionLayer,
    "Mi ubicaci칩n": userLocationLayer
}, {collapsed: false}).addTo(mymap);

$('#toggle-wm').click(function() {
    labelsEnabled = !labelsEnabled;
    $(this).text(labelsEnabled ? "TEXTO: ON" : "TEXTO: OFF");
    updateGridAndLabels();
});

mymap.on('moveend zoomend', updateGridAndLabels);

mymap.on('locationfound', function(e) {
    userLocationLayer.clearLayers();
    
    L.marker(e.latlng, {
        icon: L.divIcon({
            className: 'user-location-icon',
            html: '游늸',
            iconSize: [30, 30]
        }),
        zIndexOffset: 1000
    }).addTo(userLocationLayer);
    
    L.circle(e.latlng, {
        radius: e.accuracy / 2,
        color: '#3498db',
        fillColor: '#3498db',
        fillOpacity: 0.1,
        weight: 1
    }).addTo(userLocationLayer);
});

mymap.on('locationerror', function(e) {
    console.error("Error de ubicaci칩n:", e.message);
});

// Inicializar
updateGridAndLabels();
</script>
</body>
</html>
